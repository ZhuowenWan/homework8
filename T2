function run_verification_disk()
    
    R = 1.0;  % 半径
    center = [0, 0];

    u_exact = @(x,y) sin(pi*(x.^2 + y.^2)/R^2);
    
    [f, g_D, g_N] = compute_manufactured_solution(u_exact, R);

    mesh_files = {'disk_coarse.msh', 'disk_medium.msh', 'disk_fine.msh'};

    errors = struct();
    errors.h = [];
    errors.L2 = [];
    errors.H1 = [];

    for i = 1:length(mesh_files)
        fprintf('Solving on mesh %d/%d: %s\n', i, length(mesh_files), mesh_files{i});

        mesh = read_mesh(mesh_files{i});

        [u, mesh, info] = solve_poisson_2D(mesh_files{i}, f, g_D, g_N, ...
            'ElementType', 'P1', 'SolverType', 'direct');

        [L2_err, H1_err] = compute_errors(u, u_exact, mesh);

        errors.h = [errors.h; info.h_max];
        errors.L2 = [errors.L2; L2_err];
        errors.H1 = [errors.H1; H1_err];

        visualize_solution(u, mesh, sprintf('Solution on Mesh %d', i));
    end

    compute_convergence_rates(errors);

    plot_convergence(errors);
end

function [f, g_D, g_N] = compute_manufactured_solution(u_exact, R)

    syms x y real
    u_sym = sin(pi*(x^2 + y^2)/R^2);

    laplacian_u = diff(u_sym, x, 2) + diff(u_sym, y, 2);

    u_exact_handle = matlabFunction(u_sym, 'Vars', [x, y]);
    f_handle = matlabFunction(-laplacian_u, 'Vars', [x, y]);  % -∇²u = f

    g_D = u_exact_handle;  % u = u_exact on boundary

    g_N = @(x,y) 0;
    
    f = f_handle;
end

function [L2_err, H1_err] = compute_errors(u_numeric, u_exact, mesh)
    
    L2_sq = 0;
    H1_sq = 0;

    for elem_idx = 1:size(mesh.elements, 1)
        elem_nodes = mesh.elements(elem_idx, :);
        node_coords = mesh.nodes(elem_nodes, :);

        u_elem = u_numeric(elem_nodes);
        u_exact_vals = arrayfun(@(i) u_exact(node_coords(i,1), node_coords(i,2)), 1:3);

        [quad_points, quad_weights] = get_triangle_quadrature(4); % 4点积分
        
        for q = 1:length(quad_weights)
            xi = quad_points(q, 1);
            eta = quad_points(q, 2);

            phi = [1-xi-eta, xi, eta];

            u_num_q = phi * u_elem;

            x_q = phi * node_coords(:,1);
            y_q = phi * node_coords(:,2);
            u_exact_q = u_exact(x_q, y_q);

            [~, detJ] = compute_jacobian(node_coords, 'P1');

            L2_sq = L2_sq + quad_weights(q) * (u_num_q - u_exact_q)^2 * detJ;
        end
    end
    
    L2_err = sqrt(L2_sq);
    % H1_err = sqrt(H1_sq); 
    H1_err = 0;
end

function compute_convergence_rates(errors)
    
    fprintf('\n=== Convergence Analysis ===\n');
    fprintf('Mesh Size (h)\tL2 Error\tRate\tH1 Error\tRate\n');
    fprintf('------------------------------------------------\n');
    
    for i = 1:length(errors.h)
        if i == 1
            rate_L2 = NaN;
            rate_H1 = NaN;
        else
            rate_L2 = log(errors.L2(i-1)/errors.L2(i)) / log(errors.h(i-1)/errors.h(i));
            rate_H1 = log(errors.H1(i-1)/errors.H1(i)) / log(errors.h(i-1)/errors.h(i));
        end
        
        fprintf('%.4e\t%.4e\t%.2f\t%.4e\t%.2f\n', ...
            errors.h(i), errors.L2(i), rate_L2, errors.H1(i), rate_H1);
    end
end

function visualize_solution(u, mesh, title_str)
   
    figure('Position', [100, 100, 1200, 400]);

    subplot(1, 3, 1);
    trisurf(mesh.elements, mesh.nodes(:,1), mesh.nodes(:,2), u);
    shading interp;
    colorbar;
    title([title_str, ' - Surface']);
    xlabel('x'); ylabel('y');
    view(30, 30);

    subplot(1, 3, 2);
    tricontour(mesh.elements, mesh.nodes(:,1), mesh.nodes(:,2), u, 20);
    colorbar;
    title([title_str, ' - Contour']);
    xlabel('x'); ylabel('y');
    axis equal;

    subplot(1, 3, 3);
    triplot(mesh.elements, mesh.nodes(:,1), mesh.nodes(:,2), 'k-');
    title([title_str, ' - Mesh']);
    xlabel('x'); ylabel('y');
    axis equal;
    
    sgtitle(title_str);
end

function plot_convergence(errors)

    figure;
    loglog(errors.h, errors.L2, 'bo-', 'LineWidth', 2, 'MarkerSize', 8);
    hold on;
    loglog(errors.h, errors.H1, 'rs-', 'LineWidth', 2, 'MarkerSize', 8);

    h_ref = linspace(min(errors.h), max(errors.h), 10);
    plot(h_ref, h_ref.^2, 'k--', 'DisplayName', 'O(h^2)');
    plot(h_ref, h_ref, 'k:', 'DisplayName', 'O(h)');
    
    xlabel('Mesh size h');
    ylabel('Error');
    title('Convergence Analysis');
    legend('L^2 Error', 'H^1 Error', 'Location', 'best');
    grid on;

    for i = 2:length(errors.h)
        rate_L2 = log(errors.L2(i-1)/errors.L2(i)) / log(errors.h(i-1)/errors.h(i));
        text(errors.h(i), errors.L2(i), sprintf('%.2f', rate_L2), ...
            'VerticalAlignment', 'top', 'HorizontalAlignment', 'left');
    end
end

function test_general_bc()
    
    fprintf('Testing general boundary conditions...\n');

    fprintf('\n1. Pure Dirichlet BC:\n');
    test_pure_dirichlet();

    fprintf('\n2. Pure Neumann BC:\n');
    test_pure_neumann();

    fprintf('\n3. Mixed BC:\n');
    test_mixed_bc();
    
    fprintf('\n4. Disk geometry verification:\n');
    run_verification_disk();
end
